'use client'

import React, { useRef, useEffect, useState } from 'react';
import { CardBoundaries, transformCoordinates } from '../../../lib/boundaryCalculations';

interface CenteringData {
  measurements?: {
    left_border: number;
    right_border: number;
    top_border: number;
    bottom_border: number;
  };
  ratio?: string;
  score?: number;
}

interface OpenCVDetection {
  success?: boolean;
  detection_confidence?: string;
  geometric_center?: { x: number; y: number };
  content_center?: { x: number; y: number };
  normalized_dimensions?: { width: number; height: number };
  border_measurements?: {
    left_border: string;
    right_border: string;
    top_border: string;
    bottom_border: string;
  };
  centering_ratios?: {
    horizontal: string;
    vertical: string;
  };
  centering_score?: number;
}

interface CenteringOverlayProps {
  imageUrl: string;
  centeringData: CenteringData;
  side: 'front' | 'back';
  showOverlay: boolean;
  openCVData?: OpenCVDetection; // Optional OpenCV detection results
  userBoundaries?: CardBoundaries; // Optional user-defined card boundaries
}

export default function CenteringOverlay({ imageUrl, centeringData, side, showOverlay, openCVData, userBoundaries }: CenteringOverlayProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);
  const [imageLoaded, setImageLoaded] = useState(false);

  // Debug logging
  console.log(`[CenteringOverlay] ${side} - showOverlay:`, showOverlay);
  console.log(`[CenteringOverlay] ${side} - centeringData:`, centeringData);
  console.log(`[CenteringOverlay] ${side} - measurements:`, centeringData?.measurements);

  useEffect(() => {
    console.log(`[CenteringOverlay] ${side} - Effect triggered - imageLoaded:`, imageLoaded, 'showOverlay:', showOverlay, 'hasMeasurements:', !!centeringData?.measurements);
    if (imageLoaded && showOverlay && centeringData?.measurements) {
      drawCenteringOverlay();
    }
  }, [imageLoaded, showOverlay, centeringData]);

  const drawCenteringOverlay = () => {
    const canvas = canvasRef.current;
    const image = imageRef.current;

    console.log(`[CenteringOverlay] ${side} - Drawing overlay:`, {
      canvas: !!canvas,
      image: !!image,
      measurements: centeringData?.measurements,
      imageSize: image ? { width: image.offsetWidth, height: image.offsetHeight } : null
    });

    if (!canvas || !image || !centeringData?.measurements) {
      console.log(`[CenteringOverlay] ${side} - Cannot draw: missing requirements`);
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.log(`[CenteringOverlay] ${side} - Cannot get canvas context`);
      return;
    }

    // Set canvas size to match image display size
    canvas.width = image.offsetWidth;
    canvas.height = image.offsetHeight;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Use AI-based centering measurements (from AI instructions with precise boundary detection)
    console.log(`[CenteringOverlay] ${side} - Using AI vision centering analysis`);
    console.log(`[CenteringOverlay] ${side} - AI centering measurements:`, measurements);

    let leftBorderPct, rightBorderPct, topBorderPct, bottomBorderPct;
    let cardLeft, cardTop, cardWidth, cardHeight;

    if (useUserBoundaries) {
      // Use precise user-defined card boundaries
      const { corners } = userBoundaries!;

      // Transform corner coordinates to current canvas size
      const transformedCorners = transformCoordinates(
        corners,
        { width: userBoundaries!.imageWidth, height: userBoundaries!.imageHeight },
        { width: canvas.width, height: canvas.height }
      );

      // Calculate card boundary from corners (simplified rectangular approach)
      const minX = Math.min(...transformedCorners.map(c => c.x));
      const maxX = Math.max(...transformedCorners.map(c => c.x));
      const minY = Math.min(...transformedCorners.map(c => c.y));
      const maxY = Math.max(...transformedCorners.map(c => c.y));

      cardLeft = minX;
      cardTop = minY;
      cardWidth = maxX - minX;
      cardHeight = maxY - minY;

      // Calculate card center from actual corner geometry
      const cardCenterX = transformedCorners.reduce((sum, corner) => sum + corner.x, 0) / 4;
      const cardCenterY = transformedCorners.reduce((sum, corner) => sum + corner.y, 0) / 4;

      // Calculate border percentages based on center position within card bounds
      leftBorderPct = ((cardCenterX - cardLeft) / cardWidth) * 100;
      rightBorderPct = ((cardLeft + cardWidth - cardCenterX) / cardWidth) * 100;
      topBorderPct = ((cardCenterY - cardTop) / cardHeight) * 100;
      bottomBorderPct = ((cardTop + cardHeight - cardCenterY) / cardHeight) * 100;

      console.log(`[CenteringOverlay] ${side} - User boundaries calculation:`, {
        transformedCorners,
        cardBounds: { left: cardLeft, top: cardTop, width: cardWidth, height: cardHeight },
        cardCenter: { x: cardCenterX, y: cardCenterY },
        borderPercentages: { left: leftBorderPct, right: rightBorderPct, top: topBorderPct, bottom: bottomBorderPct }
      });

    } else if (useOpenCV) {
      // Use precise OpenCV measurements
      const parsePercentage = (value: any): number => {
        if (typeof value === 'string') {
          return parseFloat(value.replace('%', '')) || 0;
        }
        return Number(value) || 0;
      };

      leftBorderPct = parsePercentage(openCVData.border_measurements?.left_border);
      rightBorderPct = parsePercentage(openCVData.border_measurements?.right_border);
      topBorderPct = parsePercentage(openCVData.border_measurements?.top_border);
      bottomBorderPct = parsePercentage(openCVData.border_measurements?.bottom_border);

      console.log(`[CenteringOverlay] ${side} - Parsed OpenCV measurements:`, {
        left: leftBorderPct, right: rightBorderPct, top: topBorderPct, bottom: bottomBorderPct
      });

      // Use normalized card dimensions from OpenCV
      const normalizedWidth = openCVData.normalized_dimensions?.width || 250;
      const normalizedHeight = openCVData.normalized_dimensions?.height || 350;

      // Scale to current canvas size while maintaining aspect ratio
      const aspectRatio = normalizedWidth / normalizedHeight;
      const canvasAspectRatio = canvas.width / canvas.height;

      console.log(`[CenteringOverlay] ${side} - Canvas scaling:`, {
        normalizedDims: `${normalizedWidth}x${normalizedHeight}`,
        canvasDims: `${canvas.width}x${canvas.height}`,
        aspectRatio, canvasAspectRatio
      });

      // SIMPLIFIED APPROACH: Use the displayed image as the card boundary
      // Since the image IS the card, no scaling/transformation needed
      cardWidth = canvas.width;
      cardHeight = canvas.height;
      cardLeft = 0;
      cardTop = 0;

      console.log(`[CenteringOverlay] ${side} - Card boundary (simplified):`, {
        cardDims: `${cardWidth.toFixed(1)}x${cardHeight.toFixed(1)}`,
        cardPosition: `(${cardLeft.toFixed(1)}, ${cardTop.toFixed(1)})`,
        approach: 'Direct mapping - image IS the card'
      });

      console.log(`[CenteringOverlay] ${side} - OpenCV measurements:`, {
        left: leftBorderPct, right: rightBorderPct, top: topBorderPct, bottom: bottomBorderPct,
        normalizedDims: { width: normalizedWidth, height: normalizedHeight },
        cardDims: { left: cardLeft, top: cardTop, width: cardWidth, height: cardHeight }
      });

    } else {
      // Fallback to AI measurements
      const measurements = centeringData.measurements || {};
      const parsePercentage = (value: any): number => {
        if (typeof value === 'string') {
          return parseFloat(value.replace('%', '')) || 0;
        }
        return Number(value) || 0;
      };

      leftBorderPct = parsePercentage(measurements.left_border);
      rightBorderPct = parsePercentage(measurements.right_border);
      topBorderPct = parsePercentage(measurements.top_border);
      bottomBorderPct = parsePercentage(measurements.bottom_border);

      // Use estimation for card boundaries
      const cardWidthRatio = 0.8;
      const cardHeightRatio = 0.8;
      cardWidth = canvas.width * cardWidthRatio;
      cardHeight = canvas.height * cardHeightRatio;
      cardLeft = (canvas.width - cardWidth) / 2;
      cardTop = (canvas.height - cardHeight) / 2;

      console.log(`[CenteringOverlay] ${side} - AI measurements (fallback):`, {
        left: leftBorderPct, right: rightBorderPct, top: topBorderPct, bottom: bottomBorderPct
      });
    }

    // Validate measurements
    if (leftBorderPct <= 0 || rightBorderPct <= 0 || topBorderPct <= 0 || bottomBorderPct <= 0) {
      console.warn(`[CenteringOverlay] ${side} - Invalid measurements, drawing fallback`);
      drawFallbackLines(ctx, canvas);
      return;
    }

    // Calculate centering ratios from border measurements
    // The borders represent the actual border width as percentage of card dimension
    // Centering ratio = left_border / (left_border + right_border)
    console.log(`[CenteringOverlay] ${side} - Raw border measurements:`, {
      left: leftBorderPct, right: rightBorderPct, top: topBorderPct, bottom: bottomBorderPct,
      source: useOpenCV ? '[OpenCV]' : '[AI Est]'
    });

    const horizontalTotal = leftBorderPct + rightBorderPct;
    const verticalTotal = topBorderPct + bottomBorderPct;

    const leftRatio = (leftBorderPct / horizontalTotal) * 100;
    const rightRatio = (rightBorderPct / horizontalTotal) * 100;
    const topRatio = (topBorderPct / verticalTotal) * 100;
    const bottomRatio = (bottomBorderPct / verticalTotal) * 100;

    console.log(`[CenteringOverlay] ${side} - Calculated ratios:`, {
      horizontal: `${leftRatio.toFixed(1)}/${rightRatio.toFixed(1)}`,
      vertical: `${topRatio.toFixed(1)}/${bottomRatio.toFixed(1)}`
    });

    // Calculate actual centering positions within the card area
    // Horizontal centering: where the content center should be based on border measurements
    const contentCenterX = cardLeft + (cardWidth * leftRatio / 100);
    const contentCenterY = cardTop + (cardHeight * topRatio / 100);

    // Ideal centering positions (perfect 50/50)
    const idealCenterX = cardLeft + (cardWidth / 2);
    const idealCenterY = cardTop + (cardHeight / 2);

    console.log(`[CenteringOverlay] ${side} - Center positions:`, {
      actual: { x: contentCenterX, y: contentCenterY },
      ideal: { x: idealCenterX, y: idealCenterY },
      offset: { x: Math.abs(contentCenterX - idealCenterX), y: Math.abs(contentCenterY - idealCenterY) }
    });

    // Debug the red line logic
    const horizontalOffset = Math.abs(contentCenterX - idealCenterX);
    const verticalOffset = Math.abs(contentCenterY - idealCenterY);
    console.log(`[CenteringOverlay] ${side} - Offset analysis:`, {
      horizontalOffset,
      verticalOffset,
      willShowRedLines: horizontalOffset > 2 || verticalOffset > 2,
      threshold: 2
    });

    // Draw card boundary (orange dashed)
    ctx.strokeStyle = '#F59E0B'; // amber-500
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.rect(cardLeft, cardTop, cardWidth, cardHeight);
    ctx.stroke();

    // Draw ideal centering lines (green dashed)
    ctx.strokeStyle = '#10B981'; // green-500
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.8;

    // Ideal vertical line
    ctx.beginPath();
    ctx.moveTo(idealCenterX, cardTop);
    ctx.lineTo(idealCenterX, cardTop + cardHeight);
    ctx.stroke();

    // Ideal horizontal line
    ctx.beginPath();
    ctx.moveTo(cardLeft, idealCenterY);
    ctx.lineTo(cardLeft + cardWidth, idealCenterY);
    ctx.stroke();

    // Draw actual centering lines (red solid) - show for any meaningful difference
    // For 60/40 centering, we should definitely see red lines
    const shouldShowRedLines = horizontalOffset > 1 || verticalOffset > 1 ||
                              (centeringData.ratio && centeringData.ratio !== '50/50');

    console.log(`[CenteringOverlay] ${side} - Red line decision:`, {
      shouldShowRedLines,
      hasNonPerfectRatio: centeringData.ratio && centeringData.ratio !== '50/50',
      centeringRatio: centeringData.ratio
    });

    if (shouldShowRedLines) { // Show red lines for any centering that isn't perfect
      ctx.strokeStyle = '#EF4444'; // red-500
      ctx.setLineDash([]);
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.9;

      // Always draw actual vertical line for non-perfect centering
      ctx.beginPath();
      ctx.moveTo(contentCenterX, cardTop);
      ctx.lineTo(contentCenterX, cardTop + cardHeight);
      ctx.stroke();

      // Always draw actual horizontal line for non-perfect centering
      ctx.beginPath();
      ctx.moveTo(cardLeft, contentCenterY);
      ctx.lineTo(cardLeft + cardWidth, contentCenterY);
      ctx.stroke();

      console.log(`[CenteringOverlay] ${side} - Drew red lines at:`, {
        vertical: { x: contentCenterX, y1: cardTop, y2: cardTop + cardHeight },
        horizontal: { x1: cardLeft, x2: cardLeft + cardWidth, y: contentCenterY }
      });
    }

    // Add text overlays
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#1F2937'; // gray-800
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';

    // Side and ratio with source indicator
    const displayRatio = centeringData.ratio || `${leftRatio.toFixed(0)}/${rightRatio.toFixed(0)}`;
    const sourceLabel = useUserBoundaries ? '[User-Defined]' : useOpenCV ? '[OpenCV]' : '[AI Est]';
    ctx.fillText(`${side.toUpperCase()}: ${displayRatio} ${sourceLabel}`, canvas.width / 2, 20);

    // Score
    if (centeringData.score) {
      ctx.fillText(`Score: ${Number(centeringData.score).toFixed(1)}`, canvas.width / 2, 35);
    }

    // Offset information (smaller text)
    ctx.font = '10px sans-serif';
    if (shouldShowRedLines) {
      ctx.fillText(`Offset: H${horizontalOffset.toFixed(1)}px V${verticalOffset.toFixed(1)}px`, canvas.width / 2, 50);
    } else {
      ctx.fillText('Perfect Centering', canvas.width / 2, 50);
    }

    // Border measurements in corners
    ctx.textAlign = 'left';
    ctx.font = '9px sans-serif';
    ctx.fillText(`L: ${leftBorderPct.toFixed(1)}%`, 5, canvas.height - 35);
    ctx.fillText(`R: ${rightBorderPct.toFixed(1)}%`, 5, canvas.height - 20);
    ctx.fillText(`T: ${topBorderPct.toFixed(1)}%`, 5, canvas.height - 5);

    ctx.textAlign = 'right';
    ctx.fillText(`B: ${bottomBorderPct.toFixed(1)}%`, canvas.width - 5, canvas.height - 5);
  };

  const drawFallbackLines = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
    // Draw basic center lines when measurements are invalid
    ctx.strokeStyle = '#10B981';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7;

    // Vertical center line
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.stroke();

    // Horizontal center line
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();

    // Error message
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#EF4444';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Invalid measurement data', canvas.width / 2, canvas.height / 2 + 20);
  };

  const handleImageLoad = () => {
    setImageLoaded(true);
  };

  return (
    <div className="relative inline-block">
      <img
        ref={imageRef}
        src={imageUrl}
        alt={`Card ${side}`}
        className="max-w-full h-auto rounded-lg"
        onLoad={handleImageLoad}
        crossOrigin="anonymous"
      />
      <canvas
        ref={canvasRef}
        className="absolute top-0 left-0 pointer-events-none rounded-lg"
        style={{
          display: showOverlay && imageLoaded ? 'block' : 'none',
          width: '100%',
          height: '100%',
          zIndex: 10
        }}
      />
      {showOverlay && !centeringData?.measurements && (
        <div className="absolute top-2 left-2 bg-red-100 border border-red-300 text-red-700 px-2 py-1 rounded text-xs">
          No measurement data available for {side}
        </div>
      )}
      {showOverlay && centeringData?.measurements && (
        <div className="absolute top-2 right-2 bg-green-100 border border-green-300 text-green-700 px-2 py-1 rounded text-xs">
          Analysis active
        </div>
      )}
    </div>
  );
}