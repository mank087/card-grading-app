// BACKUP OF ORIGINAL route.ts BEFORE STREAMLINE IMPLEMENTATION
// Date: 2025-09-20
// This file contains the original multi-step evaluation system

import { NextRequest, NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import fs from "fs";
import path from "path";
import OpenAI from "openai";
import { cardProcessor } from "@/lib/cardProcessor";

// OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Track cards currently being processed to prevent duplicate API calls
const processingCards = new Set<string>();

// Types
type CardGradingRequest = {
  params: Promise<{ id: string }>;
};

type GradingResponse = {
  [key: string]: any;
};

// Signed URL generation
async function createSignedUrl(supabase: any, bucket: string, path: string): Promise<string | null> {
  try {
    const { data, error } = await supabase.storage
      .from(bucket)
      .createSignedUrl(path, 60 * 60); // 1 hour expiry

    if (error) {
      console.error(`Failed to create signed URL for ${path}:`, error);
      return null;
    }

    return data.signedUrl;
  } catch (error) {
    console.error(`Error creating signed URL for ${path}:`, error);
    return null;
  }
}

// Helper functions for data validation
function validateValue(value: any): any {
  if (value === undefined || value === null || value === "" || value === "N/A") {
    return null;
  }
  return value;
}

function getStringValue(value: any): string {
  const validated = validateValue(value);
  return validated !== null ? String(validated) : "Unknown";
}

function getNumericValue(value: any): number | null {
  const validated = validateValue(value);
  if (validated === null) return null;

  const parsed = parseFloat(String(validated));
  return isNaN(parsed) ? null : parsed;
}


async function gradeCardWithAI(frontUrl: string | null, backUrl: string | null, instructions: string, category: string = 'Sports', cardId: string = 'unknown'): Promise<GradingResponse> {
  // Validate inputs
  if (!frontUrl && !backUrl) {
    throw new Error("At least one image URL is required for grading");
  }

  // Generate unique session ID to prevent caching
  const sessionId = crypto.randomUUID();
  const timestamp = new Date().toISOString();

  // Create category-specific Card Details structure
  const getCardDetailsStructure = (category: string) => {
    if (category === 'Pokemon') {
      return {
        "Card Type": "[Pokémon, Trainer, Energy]",
        "Pokémon Featured": "[Pokémon name if applicable, otherwise N/A]",
        "Pokémon Stage": "[Basic, Stage 1, Stage 2, EX, GX, V, VMAX, VSTAR, LV.X, BREAK, Mega, Prism Star, Radiant, Tag Team, Delta Species, otherwise N/A]",
        "Pokémon Type": "[Grass, Fire, Water, Lightning, Psychic, Fighting, Darkness, Metal, Dragon, Fairy, Colorless, otherwise N/A]",
        "Trainer Subtype": "[Item, Supporter, Stadium, Tool, otherwise N/A]",
        "Energy Subtype": "[Basic (type name) or Special (specific name), otherwise N/A]",
        "Holofoil": "[Yes/No; if Yes specify: Standard Holo, Reverse Holo, Cosmos, Fireworks, Lenticular, Rainbow, Textured, etc.]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "First Print / Rookie Equivalent": "[Yes for 1st Edition, Shadowless, or first print run, otherwise No]",
        "Rarity": "[Common, Uncommon, Rare, Holo Rare, Reverse Holo, Ultra Rare, Secret Rare, Promo]"
      };
    } else if (category === 'Magic: The Gathering' || category === 'Magic') {
      return {
        "Card Type": "[Creature, Instant, Sorcery, Enchantment, Artifact, Planeswalker, Land, Tribal, Battle]",
        "Mana Cost": "[Exact mana symbols and cost as printed, or N/A]",
        "Color Identity": "[White, Blue, Black, Red, Green, Colorless, or specific combinations like 'White/Blue']",
        "Type Line": "[Complete type line as printed, including supertypes and subtypes]",
        "Power/Toughness": "[For creatures, exact P/T as printed, or N/A]",
        "Loyalty": "[For planeswalkers, starting loyalty, or N/A]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "Rarity": "[Common, Uncommon, Rare, Mythic Rare, Special]",
        "Foil Treatment": "[Traditional Foil, Etched Foil, Textured Foil, Galaxy Foil, or None]",
        "Frame Treatment": "[Borderless, Extended Art, Showcase, Retro Frame, or Standard]",
        "First Print / Rookie Equivalent": "[Yes for Alpha/Beta/Unlimited or first printing, otherwise No]"
      };
    } else if (category === 'Disney Lorcana' || category === 'Lorcana') {
      return {
        "Card Type": "[Character, Item, Action, Song, Location]",
        "Cost": "[Ink cost to play the card]",
        "Inkwell": "[Yes/No - Can this card be used as ink?]",
        "Color": "[Amber, Amethyst, Emerald, Ruby, Sapphire, Steel]",
        "Character Stats": "[Strength/Willpower for characters, or N/A]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "Rarity": "[Common, Uncommon, Rare, Super Rare, Legendary, Promo]",
        "Foil Treatment": "[Foil, Rainbow Foil, or None]",
        "First Print / Rookie Equivalent": "[Yes for first set printing, otherwise No]"
      };
    } else if (category === 'Yu-Gi-Oh!' || category === 'Yugioh') {
      return {
        "Card Type": "[Monster, Spell, Trap]",
        "Monster Type": "[If monster: type like Dragon, Warrior, etc., otherwise N/A]",
        "Level/Rank/Link": "[Level, Rank, or Link rating for monsters, or N/A]",
        "ATK/DEF": "[Attack/Defense values for monsters, or N/A]",
        "Attribute": "[LIGHT, DARK, FIRE, WATER, EARTH, WIND, DIVINE, or N/A]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "Rarity": "[Common, Rare, Super Rare, Ultra Rare, Secret Rare, Ghost Rare, etc.]",
        "Foil Treatment": "[Foil, Secret Rare foiling, Ghost Rare, or None]",
        "First Print / Rookie Equivalent": "[Yes for 1st Edition, otherwise No]"
      };
    } else if (category === 'One Piece') {
      return {
        "Card Type": "[Leader, Character, Event, Stage, Don!!]",
        "Cost": "[Play cost of the card]",
        "Power": "[Power value for characters, or N/A]",
        "Color": "[Red, Green, Blue, Purple, Yellow, Black]",
        "Rarity": "[Common, Uncommon, Rare, Super Rare, Secret Rare, Special Rare]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "Foil Treatment": "[Foil, Alternate Art, or None]",
        "First Print / Rookie Equivalent": "[Yes for first printing, otherwise No]"
      };
    } else {
      // Default structure for Sports cards and others
      return {
        "Player(s)/Character(s) Featured": "[Main subject of the card]",
        "Rookie/First Print": "[Yes/No - Is this a rookie card or first print?]",
        "Autographed": "[Yes/No - Look for signatures, autograph stickers, or 'Auto' text anywhere on the card]",
        "Rarity": "[Base, Parallel, Short Print, Numbered, etc.]"
      };
    }
  };

  const cardDetailsStructure = getCardDetailsStructure(category);

  try {
    // Create conversation thread with enhanced instructions
    const thread = await openai.beta.threads.create();
    console.log(`Created OpenAI thread: ${thread.id}`);

    // Build message content with images
    const messageContent: any[] = [
      {
        type: "text",
        text: `Session ID: ${sessionId}
Timestamp: ${timestamp}

${instructions}

RESPONSE STRUCTURE (Return as valid JSON only):
{
  "Card Information": {
    "Card Name": "[Exact card name as visible]",
    "Category": "${category}",
    "Card Number": "[Card number if visible, otherwise 'Unknown']",
    "Serial Numbering": "[Serial number if present, e.g., '#25/99', or 'N/A']",
    "Card Set": "[Set name if visible, otherwise 'Unknown']",
    "Manufacturer Name": "[Card manufacturer]",
    "Release Date": "[Year of release if determinable, otherwise 'Unknown']",
    "Authentic": "[Yes/No based on visual inspection]"
  },
  "Card Details": ${JSON.stringify(cardDetailsStructure, null, 2)},
  "Final Score": {
    "Overall Grade": "[Your final grade on DCM scale 1-10] / [AI confidence A-D]"
  },
  "Grading (DCM Master Scale)": {
    "Raw Decimal Grade (Before Rounding)": [Decimal grade, e.g., 8.7],
    "DCM Grade (Final Whole Number)": [Final whole number grade, e.g., 9],
    "Subgrade Evaluation": {
      "Corners": {"score": [1-10], "commentary": "[Specific observations]"},
      "Edges": {"score": [1-10], "commentary": "[Specific observations]"},
      "Surface Front": {"score": [1-10], "commentary": "[Specific observations]"},
      "Surface Back": {"score": [1-10], "commentary": "[Specific observations]"},
      "Centering Front": {"ratio": "[ratio e.g., 60/40]", "commentary": "[Specific observations]"},
      "Centering Back": {"ratio": "[ratio e.g., 75/25]", "commentary": "[Specific observations]"},
      "Print Quality": {"score": [1-10], "commentary": "[Specific observations]"},
      "Summary for Grade": "[Comprehensive explanation of grade reasoning]"
    }
  },
  "DCM Score System": {
    "Condition Grade (Base)": [Numeric grade 1-10],
    "AI Confidence Score": "[A, B, C, or D based on image quality]",
    "Final DCM Score": "[Format: 'Grade / Confidence', e.g., '8 / B']"
  },
  "DCM Estimated Value": {
    "Estimated Market Value": "[Dollar amount, e.g., '$25']",
    "Estimated Range": "[Range, e.g., '$20 - $30']",
    "Estimate Confidence": "[High, Medium, or Low]"
  }
}`
      }
    ];

    // Add images to the message
    if (frontUrl) {
      messageContent.push({
        type: "image_url",
        image_url: {
          url: frontUrl,
          detail: "high"
        }
      });
    }

    if (backUrl) {
      messageContent.push({
        type: "image_url",
        image_url: {
          url: backUrl,
          detail: "high"
        }
      });
    }

    // Add the message to the thread
    await openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: messageContent
    });

    // Create and run the assistant
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: process.env.OPENAI_ASSISTANT_ID!,
    });

    console.log(`Started OpenAI run: ${run.id}`);

    // Poll for completion
    let runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
    let attempts = 0;
    const maxAttempts = 60; // 5 minutes max

    while (runStatus.status === "in_progress" || runStatus.status === "queued") {
      await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
      runStatus = await openai.beta.threads.runs.retrieve(thread.id, run.id);
      attempts++;
      console.log(`Run status check ${attempts}: ${runStatus.status}`);

      if (attempts >= maxAttempts) {
        throw new Error("OpenAI run timed out");
      }
    }

    if (runStatus.status === "completed") {
      // Get the assistant's response
      const messages = await openai.beta.threads.messages.list(thread.id);
      const response = messages.data[0];

      if (response.content[0].type === "text") {
        const rawResponse = response.content[0].text.value;
        console.log("Raw AI Response:", rawResponse.substring(0, 200) + "...");

        // Clean and parse JSON
        let jsonPart = rawResponse.replace(/```json|```/g, "").trim();

        const gradingResult = JSON.parse(jsonPart);

        // Support both old and new AI response formats
        const hasFinalScore = gradingResult["Final Score"];
        const hasFinalDCMGrade = gradingResult["Final DCM Grade"];
        const hasCardInfo = gradingResult["Card Information"] || gradingResult["Card Identification"];

        if (!(hasFinalScore || hasFinalDCMGrade) || !hasCardInfo) {
          throw new Error("Invalid grading result structure");
        }

        return gradingResult;
      }
    } else {
      // Retry logic for failed runs
      console.log(`[OpenAI] Run failed with status: ${runStatus.status}, attempting retry...`);

      // Clean up failed thread
      try {
        await openai.beta.threads.del(thread.id);
        console.log(`Cleaned up thread: ${thread.id}`);
      } catch (cleanupError) {
        console.error("Failed to cleanup thread:", cleanupError);
      }

      // If we have retries left, try again
      if (attempts < 2) {
        console.log(`[OpenAI] Retrying AI grading (attempt ${attempts + 1})`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
        return gradeCardWithAI(frontUrl, backUrl, instructions, category, cardId);
      } else {
        throw new Error(`OpenAI run failed with status: ${runStatus.status}`);
      }
    }
  } catch (error) {
    console.error("AI grading error:", error);
    throw error;
  } finally {
    // Clean up the thread
    try {
      // Note: We're not deleting the thread here to allow for debugging
      // await openai.beta.threads.del(thread.id);
    } catch (cleanupError) {
      console.error("Failed to cleanup thread:", cleanupError);
    }
  }
}

// Category-specific instruction loading
function getCategoryInstructions(category: string): string {
  const instructionFiles: { [key: string]: string } = {
    'Pokemon': 'pokemon_assistant_instructions_master.txt',
    'Magic: The Gathering': 'magic_assistant_instructions.txt',
    'Disney Lorcana': 'lorcana_assistant_instructions.txt',
    'Yu-Gi-Oh!': 'yugioh_assistant_instructions.txt',
    'One Piece': 'onepiece_assistant_instructions.txt',
    'Sports': 'sports_assistant_instructions.txt',
    // Add more categories as needed
  };

  const filename = instructionFiles[category] || instructionFiles['Sports']; // Default to Sports
  const filePath = path.join(process.cwd(), filename);

  try {
    if (fs.existsSync(filePath)) {
      return fs.readFileSync(filePath, "utf8");
    } else {
      console.warn(`Instructions file not found: ${filePath}`);
      return "Basic card grading instructions - evaluate condition, authenticity, and assign grade 1-10.";
    }
  } catch (error) {
    console.error(`Error loading instructions for ${category}:`, error);
    return "Basic card grading instructions - evaluate condition, authenticity, and assign grade 1-10.";
  }
}

async function getCardEvaluationStatus(supabase: any, cardId: string) {
  const { data: card } = await supabase
    .from("cards")
    .select("ai_grading, evaluation_status, completed_evaluations, target_evaluations, consensus_raw_grade, consensus_whole_grade")
    .eq("id", cardId)
    .single();

  const evaluationData = card?.ai_grading?.evaluation_progress || {};
  const evaluations = card?.ai_grading?.multi_evaluations || [];

  return {
    evaluation_status: evaluationData.status || card?.evaluation_status || 'pending',
    completed_evaluations: evaluations.length || card?.completed_evaluations || 0,
    target_evaluations: evaluationData.target || card?.target_evaluations || 3,
    consensus_raw_grade: card?.consensus_raw_grade,
    consensus_whole_grade: card?.consensus_whole_grade
  };
}

async function getNextEvaluationNumber(supabase: any, cardId: string): Promise<number> {
  const { data: card } = await supabase
    .from("cards")
    .select("ai_grading")
    .eq("id", cardId)
    .single();

  const evaluationData = card?.ai_grading?.evaluation_progress || {};
  return (evaluationData.completed || 0) + 1;
}

async function saveEvaluation(supabase: any, cardId: string, evaluationNumber: number, gradingResult: any, category: string) {
  // Handle both old and new AI response formats
  const finalGrade = gradingResult["Final DCM Grade"] || {};
  const oldGrading = gradingResult["Grading (DCM Master Scale)"] || {};
  const oldSystem = gradingResult["DCM Score System"] || {};

  const rawGrade = parseFloat(
    finalGrade["Raw Decimal Grade"] ||
    oldGrading["Raw Decimal Grade (Before Rounding)"] ||
    oldSystem["Condition Grade (Base)"] ||
    "0"
  );

  const wholeGrade = parseInt(
    finalGrade["DCM Grade (Whole Number)"] ||
    oldGrading["DCM Grade (Final Whole Number)"] ||
    oldSystem["Condition Grade (Base)"] ||
    "0"
  );

  const confidence = finalGrade["Confidence Level"] || oldSystem["AI Confidence Score"] || "C";

  // Process card data with CardProcessor for Pokemon cards
  let processedCardData = null;
  if (category.toLowerCase() === 'pokemon') {
    try {
      console.log(`[GET /api/card/${cardId}] Processing Pokemon card with API integration`);
      processedCardData = await cardProcessor.processCardData(gradingResult, category);
      console.log(`[GET /api/card/${cardId}] Pokemon API processing completed`);
    } catch (error: any) {
      console.error(`[GET /api/card/${cardId}] Pokemon API processing failed:`, error.message);
    }
  }

  // Get existing evaluations from ai_grading JSON
  const { data: card } = await supabase
    .from("cards")
    .select("ai_grading")
    .eq("id", cardId)
    .single();

  const currentGrading = card?.ai_grading || {};
  const evaluations = currentGrading.multi_evaluations || [];

  // Add this evaluation
  evaluations.push({
    evaluation_number: evaluationNumber,
    raw_grade: rawGrade,
    whole_grade: wholeGrade,
    confidence: confidence,
    grading_result: gradingResult,
    processed_card_data: processedCardData,
    completed_at: new Date().toISOString()
  });

  // Update the card with new evaluation
  const updatedGrading = {
    ...currentGrading,
    multi_evaluations: evaluations,
    evaluation_progress: {
      completed: evaluationNumber,
      target: 3,
      status: evaluationNumber >= 3 ? 'completed' : 'processing'
    }
  };

  await supabase
    .from("cards")
    .update({ ai_grading: updatedGrading })
    .eq("id", cardId);

  return { rawGrade, wholeGrade, confidence, processedCardData };
}

async function calculateConsensusScore(supabase: any, cardId: string) {
  const { data: card } = await supabase
    .from("cards")
    .select("ai_grading")
    .eq("id", cardId)
    .single();

  const evaluations = card?.ai_grading?.multi_evaluations || [];
  if (evaluations.length === 0) return null;

  // Calculate averages
  const avgRawGrade = evaluations.reduce((sum: number, e: any) => sum + e.raw_grade, 0) / evaluations.length;
  const avgWholeGrade = Math.round(evaluations.reduce((sum: number, e: any) => sum + e.whole_grade, 0) / evaluations.length);

  // Determine consensus confidence (most conservative approach - lowest confidence)
  const confidenceLevels: {[key: string]: number} = { A: 4, B: 3, C: 2, D: 1 };
  const lowestConfidence = evaluations.reduce((lowest: string, e: any) => {
    return confidenceLevels[e.confidence] < confidenceLevels[lowest] ? e.confidence : lowest;
  }, evaluations[0].confidence);

  return {
    consensus_raw_grade: Math.round(avgRawGrade * 100) / 100, // Round to 2 decimal places
    consensus_whole_grade: avgWholeGrade,
    consensus_confidence: lowestConfidence,
    total_evaluations: evaluations.length
  };
}

async function updateCardConsensusScore(supabase: any, cardId: string) {
  const consensus = await calculateConsensusScore(supabase, cardId);
  if (!consensus) return;

  // Get Pokemon card data from the latest evaluation if available
  const { data: card } = await supabase
    .from("cards")
    .select("ai_grading")
    .eq("id", cardId)
    .single();

  const evaluations = card?.ai_grading?.multi_evaluations || [];
  let pokemonData = {};

  // Use Pokemon data from the latest evaluation that has processed_card_data
  for (const evaluation of evaluations.reverse()) {
    if (evaluation.processed_card_data?.databaseFields) {
      const dbFields = evaluation.processed_card_data.databaseFields;

      // Extract Pokemon-specific fields if they exist
      if (dbFields.card_type) {
        console.log(`[updateCardConsensusScore] Saving Pokemon API data for card ${cardId}`);
        pokemonData = {
          card_type: dbFields.card_type,
          pokemon_featured: dbFields.pokemon_featured,
          pokemon_stage: dbFields.pokemon_stage,
          pokemon_type: dbFields.pokemon_type,
          trainer_subtype: dbFields.trainer_subtype,
          energy_subtype: dbFields.energy_subtype,
          hp: dbFields.hp,
          rarity_description: dbFields.rarity_description,
          estimated_market_value: dbFields.estimated_market_value,
          pokemon_tcg_api_id: dbFields.pokemon_tcg_api_id,
          pokemon_tcg_data: dbFields.pokemon_tcg_data
        };
        break;
      }
    }
  }

  await supabase
    .from("cards")
    .update({
      consensus_raw_grade: consensus.consensus_raw_grade,
      consensus_whole_grade: consensus.consensus_whole_grade,
      consensus_confidence: consensus.consensus_confidence,
      completed_evaluations: consensus.total_evaluations,
      evaluation_status: 'completed',
      ...pokemonData // Spread Pokemon data if available
    })
    .eq("id", cardId);
}

// Main API Route Handler
export async function GET(request: Request, context: CardGradingRequest) {
  const startTime = Date.now();
  let cardId: string;

  try {
    const { id } = await context.params;
    cardId = id;

    console.log(`[GET /api/card/${cardId}] Starting request`);

    // Check if this card is already being processed
    if (processingCards.has(cardId)) {
      console.log(`[GET /api/card/${cardId}] Card already being processed, waiting...`);
      // Wait a bit and try to get the updated card from database
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    const supabase = supabaseServer();

    // 1. Fetch card from database
    const { data: card, error: fetchError } = await supabase
      .from("cards")
      .select("*")
      .eq("id", cardId)
      .single();

    if (fetchError || !card) {
      console.error(`[GET /api/card/${cardId}] Card not found:`, fetchError);
      return NextResponse.json(
        { error: "Card not found" },
        { status: 404 }
      );
    }

    console.log(`[GET /api/card/${cardId}] Card found`);

    // 2. Generate signed URLs for images
    const frontUrl = await createSignedUrl(supabase, "cards", card.front_path);
    const backUrl = await createSignedUrl(supabase, "cards", card.back_path);

    // 3. Check evaluation status using multi-evaluation system
    const evaluationStatus = await getCardEvaluationStatus(supabase, cardId);

    if (evaluationStatus?.evaluation_status === 'completed') {
      console.log(`[GET /api/card/${cardId}] All evaluations completed, returning consensus result`);
      return NextResponse.json({
        ...card,
        front_url: frontUrl,
        back_url: backUrl,
        evaluation_progress: {
          status: 'completed',
          completed: evaluationStatus.completed_evaluations,
          target: evaluationStatus.target_evaluations,
          consensus_grade: evaluationStatus.consensus_whole_grade,
          consensus_raw: evaluationStatus.consensus_raw_grade
        }
      });
    }

    // 4. Check if we should start a new evaluation
    const nextEvaluationNumber = await getNextEvaluationNumber(supabase, cardId);
    const targetEvaluations = evaluationStatus?.target_evaluations || 3;

    if (nextEvaluationNumber > targetEvaluations) {
      console.log(`[GET /api/card/${cardId}] Target evaluations reached, calculating final consensus`);
      await updateCardConsensusScore(supabase, cardId);

      // Return updated card with consensus
      const { data: finalCard } = await supabase
        .from("cards")
        .select("*")
        .eq("id", cardId)
        .single();

      return NextResponse.json({
        ...finalCard,
        front_url: frontUrl,
        back_url: backUrl,
        evaluation_progress: {
          status: 'completed',
          completed: targetEvaluations,
          target: targetEvaluations,
          consensus_grade: finalCard.consensus_whole_grade,
          consensus_raw: finalCard.consensus_raw_grade
        }
      });
    }

    console.log(`[GET /api/card/${cardId}] Starting evaluation ${nextEvaluationNumber} of ${targetEvaluations}`);

    // 5. Initialize evaluation tracking if this is the first evaluation
    if (nextEvaluationNumber === 1) {
      await supabase
        .from("cards")
        .update({
          evaluation_status: 'processing',
          total_evaluations: 0,
          completed_evaluations: 0,
          target_evaluations: targetEvaluations
        })
        .eq("id", cardId);
    }

    // 4. Validate we have at least one image
    if (!frontUrl && !backUrl) {
      console.warn(`[GET /api/card/${cardId}] No valid images for grading`);
      return NextResponse.json(
        {
          error: "No valid images available for grading",
          front_url: frontUrl,
          back_url: backUrl
        },
        { status: 400 }
      );
    }

    // 5. Get category-specific instructions and proceed with AI grading
    const category = card.category || 'Sports'; // Default to Sports if no category
    const instructions = getCategoryInstructions(category);

    console.log(`[GET /api/card/${cardId}] Starting AI grading`);
    console.log(`[GET /api/card/${cardId}] Using ${category} grading instructions`);

    // Mark this card as being processed
    processingCards.add(cardId);
    console.log(`[GET /api/card/${cardId}] Instructions file content preview:`, instructions.substring(0, 200));

    // 6. Execute AI grading directly (instructions included in message)
    const gradingResult = await gradeCardWithAI(frontUrl, backUrl, instructions, category, cardId);

    console.log(`[GET /api/card/${cardId}] AI grading completed`);

    const cardInfo = gradingResult["Card Information"] || gradingResult["Card Identification"] || {};
    const cardDetails = gradingResult["Card Details"] || gradingResult["Physical Condition Assessment"] || {};
    const wholeGrade = getNumericValue(gradingResult["DCM Score System"]?.["Condition Grade (Base)"]) || 5;


    // 8. Extract and process grading data
    const dcmScoreSystem = gradingResult["DCM Score System"] || {};
    const gradingMasterScale = gradingResult["Grading (DCM Master Scale)"] || {};

    const rawDecimalGrade = getNumericValue(gradingMasterScale["Raw Decimal Grade (Before Rounding)"]) || wholeGrade;

    // Map confidence score
    let aiConfidence = dcmScoreSystem["AI Confidence Score"];
    if (typeof aiConfidence === "string") {
      switch (aiConfidence.toLowerCase()) {
        case "high": aiConfidence = "A"; break;
        case "medium": aiConfidence = "B"; break;
        case "low": aiConfidence = "C"; break;
        case "very low": aiConfidence = "D"; break;
      }
    }

    // 9. Update card in database
    const finalScore = gradingResult["Final Score"] || {};
    const dcmEstimatedValue = gradingResult["DCM Estimated Value"] || {};
    const subgradeEval = gradingMasterScale["Subgrade Evaluation"] || {};

    // Prepare update data based on category
    const baseUpdateData = {
      ai_grading: gradingResult,
      card_name: getStringValue(cardInfo["Card Name"]),
      category: getStringValue(cardInfo["Category"]),
      card_number: getStringValue(cardInfo["Card Number"]),
      serial_numbering: getStringValue(cardInfo["Serial Numbering"]),
      card_set: getStringValue(cardInfo["Card Set"]),
      manufacturer_name: getStringValue(cardInfo["Manufacturer Name"]),
      release_date: getStringValue(cardInfo["Release Date"]),
      authentic: getStringValue(cardInfo["Authentic"]),
      rarity_description: getStringValue(cardDetails["Rarity"]),
      raw_decimal_grade: rawDecimalGrade,
      dcm_grade_whole: wholeGrade,
      explanation: getStringValue(subgradeEval["Summary for Grade"]),
      summary: getStringValue(subgradeEval["Summary for Grade"]),
      grade_numeric: wholeGrade,
      grade_quality: wholeGrade >= 9 ? "Mint" : wholeGrade >= 7 ? "Near Mint" : wholeGrade >= 5 ? "Good" : "Poor",
      condition_grade_base: wholeGrade,
      ai_confidence_score: aiConfidence || "C",
      final_dcm_score: `${wholeGrade} / ${aiConfidence || "C"}`,
      estimated_market_value: getNumericValue(dcmEstimatedValue["Estimated Market Value"]?.replace(/[\$,]/g, "")),
      estimated_range: getStringValue(dcmEstimatedValue["Estimated Range"]),
      estimate_confidence: getStringValue(dcmEstimatedValue["Estimate Confidence"]),
      obstruction_summary: null // Reset any previous obstruction data
    };

    // Add category-specific fields
    if (category === 'Pokemon') {
      const detectedCategory = cardInfo["Category"]?.toLowerCase().includes('pokemon') ? 'Pokemon' : category;
      console.log(`[GET /api/card/${cardId}] Detected category: ${detectedCategory}`);
      console.log(`[GET /api/card/${cardId}] Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Card Details content:`, cardDetails);

      const pokemonData = {
        card_type: getStringValue(cardDetails["Card Type"]),
        pokemon_featured: getStringValue(cardDetails["Pokémon Featured"]),
        pokemon_stage: getStringValue(cardDetails["Pokémon Stage"]),
        pokemon_type: getStringValue(cardDetails["Pokémon Type"]),
        trainer_subtype: cardDetails["Trainer Subtype"] === 'N/A' ? null : getStringValue(cardDetails["Trainer Subtype"]),
        energy_subtype: cardDetails["Energy Subtype"] === 'N/A' ? null : getStringValue(cardDetails["Energy Subtype"]),
        holofoil: getStringValue(cardDetails["Holofoil"]),
        first_print_rookie: getStringValue(cardDetails["First Print / Rookie Equivalent"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Pokemon data to save:`, pokemonData);

      Object.assign(baseUpdateData, pokemonData);
    } else if (category === 'Magic: The Gathering' || category === 'Magic') {
      const magicData = {
        card_type: getStringValue(cardDetails["Card Type"]),
        mana_cost: getStringValue(cardDetails["Mana Cost"]),
        color_identity: getStringValue(cardDetails["Color Identity"]),
        power_toughness: getStringValue(cardDetails["Power/Toughness"]),
        first_print_rookie: getStringValue(cardDetails["First Print / Rookie Equivalent"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Magic data to save:`, magicData);

      Object.assign(baseUpdateData, magicData);
    } else if (category === 'Disney Lorcana' || category === 'Lorcana') {
      const lorcanaData = {
        card_type: getStringValue(cardDetails["Card Type"]),
        cost: getNumericValue(cardDetails["Cost"]),
        inkwell: getStringValue(cardDetails["Inkwell"]),
        color: getStringValue(cardDetails["Color"]),
        character_stats: getStringValue(cardDetails["Character Stats"]),
        first_print_rookie: getStringValue(cardDetails["First Print / Rookie Equivalent"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Lorcana data to save:`, lorcanaData);

      Object.assign(baseUpdateData, lorcanaData);
    } else if (category === 'Yu-Gi-Oh!' || category === 'Yugioh') {
      const yugiohData = {
        card_type: getStringValue(cardDetails["Card Type"]),
        monster_type: getStringValue(cardDetails["Monster Type"]),
        level_rank_link: getStringValue(cardDetails["Level/Rank/Link"]),
        atk_def: getStringValue(cardDetails["ATK/DEF"]),
        attribute: getStringValue(cardDetails["Attribute"]),
        first_print_rookie: getStringValue(cardDetails["First Print / Rookie Equivalent"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Yu-Gi-Oh data to save:`, yugiohData);

      Object.assign(baseUpdateData, yugiohData);
    } else if (category === 'One Piece') {
      const onepieceData = {
        card_type: getStringValue(cardDetails["Card Type"]),
        cost: getNumericValue(cardDetails["Cost"]),
        power: getNumericValue(cardDetails["Power"]),
        color: getStringValue(cardDetails["Color"]),
        first_print_rookie: getStringValue(cardDetails["First Print / Rookie Equivalent"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] One Piece data to save:`, onepieceData);

      Object.assign(baseUpdateData, onepieceData);
    } else {
      // Sports and other categories
      const otherData = {
        players_featured: getStringValue(cardDetails["Player(s)/Character(s) Featured"]),
        rookie_card: getStringValue(cardDetails["Rookie/First Print"]),
        autographed: getStringValue(cardDetails["Autographed"])
      };

      console.log(`[GET /api/card/${cardId}] Raw Card Details keys:`, Object.keys(cardDetails || {}));
      console.log(`[GET /api/card/${cardId}] Other data to save:`, otherData);

      Object.assign(baseUpdateData, otherData);
    }

    // Save the evaluation first
    console.log(`[GET /api/card/${cardId}] Saving evaluation ${nextEvaluationNumber}`);

    await saveEvaluation(supabase, cardId, nextEvaluationNumber, gradingResult, category);

    // Update the main card fields with base data
    const { error: updateError } = await supabase
      .from("cards")
      .update(baseUpdateData)
      .eq("id", cardId);

    if (updateError) {
      console.error("Failed to update card:", updateError);
    }

    // Check if we've completed all evaluations
    if (nextEvaluationNumber >= targetEvaluations) {
      console.log(`[GET /api/card/${cardId}] Calculating consensus from ${nextEvaluationNumber} evaluations`);
      await updateCardConsensusScore(supabase, cardId);

      // Get the updated card with consensus scores
      const { data: updatedCard } = await supabase
        .from("cards")
        .select("*")
        .eq("id", cardId)
        .single();

      const { data: finalCard } = await supabase
        .from("cards")
        .select("*")
        .eq("id", cardId)
        .single();

      const duration = Date.now() - startTime;
      console.log(`[GET /api/card/${cardId}] Request completed in ${duration}ms`);

      return NextResponse.json({
        ...finalCard,
        front_url: frontUrl,
        back_url: backUrl,
        evaluation_progress: {
          status: 'completed',
          completed: targetEvaluations,
          target: targetEvaluations,
          consensus_grade: finalCard.consensus_whole_grade,
          consensus_raw: finalCard.consensus_raw_grade
        }
      });
    }

    const duration = Date.now() - startTime;
    console.log(`[GET /api/card/${cardId}] Request completed in ${duration}ms`);

    // Return the updated card
    const { data: updatedCard } = await supabase
      .from("cards")
      .select("*")
      .eq("id", cardId)
      .single();

    return NextResponse.json({
      ...updatedCard,
      front_url: frontUrl,
      back_url: backUrl,
      evaluation_progress: {
        status: 'processing',
        completed: nextEvaluationNumber,
        target: targetEvaluations
      }
    });

  } catch (error: any) {
    const duration = Date.now() - startTime;
    console.error(`[GET /api/card/${cardId || 'unknown'}] Error after ${duration}ms:`, error);

    return NextResponse.json(
      {
        error: "Failed to grade card",
        details: error.message,
        evaluation_progress: {
          status: 'error',
          completed: 0,
          target: 3
        }
      },
      { status: 500 }
    );
  } finally {
    // Always remove from processing set
    if (cardId) {
      processingCards.delete(cardId);
      console.log(`[GET /api/card/${cardId}] Removed from processing set`);
    }
  }
}