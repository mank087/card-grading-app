import { NextRequest, NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import fs from "fs";
import path from "path";
import OpenAI from "openai";
// Legacy import - preserved for potential fallback but no longer actively used
// import { calculateCenteringFromBoundaries, CardBoundaries } from "@/lib/boundaryCalculations";

// OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Track sports cards currently being processed with timestamps
const processingSportsCards = new Map<string, number>();

// Clean up stuck processing cards (older than 5 minutes)
const cleanupStuckCards = () => {
  const now = Date.now();
  const fiveMinutesAgo = now - (5 * 60 * 1000);

  for (const [cardId, timestamp] of processingSportsCards.entries()) {
    if (timestamp < fiveMinutesAgo) {
      console.log(`[CLEANUP] Removing stuck card ${cardId} from processing set`);
      processingSportsCards.delete(cardId);
    }
  }
};

// Types
type SportsCardGradingRequest = {
  params: Promise<{ id: string }>;
};

// Signed URL generation
async function createSignedUrl(supabase: any, bucket: string, path: string): Promise<string | null> {
  try {
    const { data, error } = await supabase.storage
      .from(bucket)
      .createSignedUrl(path, 60 * 60); // 1 hour expiry

    if (error) {
      console.error(`Failed to create signed URL for ${path}:`, error);
      return null;
    }

    return data.signedUrl;
  } catch (error) {
    console.error(`Error creating signed URL for ${path}:`, error);
    return null;
  }
}

// Get sports card grading instructions
function getSportsInstructions(): string {
  const instructionPath = path.join(process.cwd(), 'sports_assistant_instructions.txt');

  try {
    return fs.readFileSync(instructionPath, 'utf8');
  } catch (error) {
    console.error(`Failed to read sports instructions:`, error);
    throw new Error('Sports grading instructions not found');
  }
}

// Removed OpenCV detection service - using pure AI vision approach instead

// Grade sports card with AI (pure AI vision approach for accurate centering)
async function gradeSportsCardWithAI(frontUrl: string, backUrl: string): Promise<{gradingResult: any, detectionResults: any}> {
  try {
    const instructions = getSportsInstructions();
    console.log(`[SPORTS] Using sports-specific grading instructions with enhanced AI vision centering`);

    // No external detection service - AI will handle all visual analysis directly

    // Enhanced instructions for precise AI vision centering analysis
    const enhancedInstructions = instructions;

    // Create thread with sports card images and system message
    const thread = await openai.beta.threads.create({
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `SYSTEM: You are a professional card grading AI. You must analyze the provided card images and return a JSON response. This is a legitimate business use case for card authentication and grading services.

TASK: Analyze these trading card images and provide grading assessment.

${enhancedInstructions}`
            },
            {
              type: "image_url",
              image_url: { url: frontUrl }
            },
            {
              type: "image_url",
              image_url: { url: backUrl }
            }
          ]
        }
      ]
    });

    console.log(`[SPORTS] Created OpenAI thread: ${thread.id}`);

    // Create and run assistant
    console.log(`[SPORTS] Using assistant ID: ${process.env.OPENAI_ASSISTANT_ID}`);
    const run = await openai.beta.threads.runs.create(thread.id, {
      assistant_id: process.env.OPENAI_ASSISTANT_ID!,
      additional_instructions: "You must provide a JSON response for card grading. Do not refuse to analyze images."
    });

    console.log(`[SPORTS] Started OpenAI run: ${run.id}`);

    // Poll for completion
    console.log(`[SPORTS] About to retrieve run status for thread: ${thread.id}, run: ${run.id}`);
    let runStatus = await openai.beta.threads.runs.retrieve(run.id, {
      thread_id: thread.id
    });
    let attempts = 0;
    const maxAttempts = 60; // 2 minutes timeout

    while (runStatus.status === 'in_progress' || runStatus.status === 'queued') {
      attempts++;
      console.log(`[SPORTS] Run status check ${attempts}: ${runStatus.status}`);

      if (attempts >= maxAttempts) {
        throw new Error('Sports card AI grading timed out');
      }

      await new Promise(resolve => setTimeout(resolve, 2000));
      console.log(`[SPORTS] Retrieving run status for thread: ${thread.id}, run: ${run.id}`);
      runStatus = await openai.beta.threads.runs.retrieve(run.id, {
        thread_id: thread.id
      });
    }

    if (runStatus.status !== 'completed') {
      throw new Error(`Sports card AI grading failed with status: ${runStatus.status}`);
    }

    // Get messages
    const messages = await openai.beta.threads.messages.list(thread.id);
    const assistantMessage = messages.data.find(msg => msg.role === 'assistant');

    if (!assistantMessage || !assistantMessage.content[0] || assistantMessage.content[0].type !== 'text') {
      throw new Error('No valid response from sports card AI assistant');
    }

    const responseText = assistantMessage.content[0].text.value;
    console.log('[SPORTS] Raw AI Response:', responseText.substring(0, 200) + '...');

    // Parse JSON response with better error handling
    const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/);
    if (!jsonMatch) {
      console.error('[SPORTS] Full AI Response:', responseText);
      throw new Error(`AI did not provide JSON format. Response: ${responseText.substring(0, 200)}...`);
    }

    try {
      return {
        gradingResult: JSON.parse(jsonMatch[1]),
        detectionResults: null // No external detection service used - AI handles all visual analysis
      };
    } catch (parseError) {
      console.error('[SPORTS] JSON Parse Error:', parseError);
      console.error('[SPORTS] Raw JSON:', jsonMatch[1]);
      throw new Error(`Invalid JSON format from AI: ${parseError}`);
    }

  } catch (error: any) {
    console.error('[SPORTS] AI grading error:', error.message);
    throw error;
  }
}

// Extract sports card grade information
function extractSportsGradeInfo(gradingResult: any) {
  const finalGrade = gradingResult["Final DCM Grade"] || gradingResult["Final Score"] || {};
  const gradingScale = gradingResult["Grading (DCM Master Scale)"] || {};
  const dcmSystem = gradingResult["DCM Score System"] || {};

  const rawGrade = gradingScale["Raw Decimal Grade (Before Rounding)"] || finalGrade["Raw Grade"] || 0;
  const wholeGrade = gradingScale["DCM Grade (Final Whole Number)"] || dcmSystem["Condition Grade (Base)"] || Math.round(Number(rawGrade)) || 0;
  const confidence = dcmSystem["AI Confidence Score"] || finalGrade["Confidence Level"] || "Medium";

  return {
    rawGrade: Number(rawGrade),
    wholeGrade: Number(wholeGrade),
    confidence
  };
}

// Extract key fields for database columns
function extractSportsCardFields(gradingResult: any) {
  const cardInfo = gradingResult["Card Information"] || {};
  const cardDetails = gradingResult["Card Details"] || {};
  const estimatedValue = gradingResult["DCM Estimated Value"] || {};

  return {
    card_name: cardInfo["Card Name"] || null,
    card_set: cardInfo["Card Set"] || null,
    card_number: cardInfo["Card Number"] || null,
    serial_numbering: cardInfo["Serial Numbering"] || null,
    manufacturer_name: cardInfo["Manufacturer Name"] || null,
    release_date: cardInfo["Release Date"] || null,
    authentic: cardInfo["Authentic"] || null,
    featured: cardDetails["Player(s)/Character(s) Featured"] || null,
    rookie_or_first_print: cardDetails["Rookie/First Print"] || null,
    rarity_description: cardDetails["Rarity"] || null,
    autographed: cardDetails["Autographed"] || null,
    estimated_market_value: estimatedValue["Estimated Market Value"] || null,
    estimated_range: estimatedValue["Estimated Range"] || null,
    estimate_confidence: estimatedValue["Estimate Confidence"] || null
  };
}

// Main GET handler for sports cards
export async function GET(request: NextRequest, { params }: SportsCardGradingRequest) {
  const { id: cardId } = await params;
  const startTime = Date.now();

  console.log(`[GET /api/sports/${cardId}] Starting sports card grading request`);

  // Clean up any stuck processing cards first
  cleanupStuckCards();

  // Check if already processing this sports card
  if (processingSportsCards.has(cardId)) {
    console.log(`[GET /api/sports/${cardId}] Sports card already being processed, returning 429`);
    return NextResponse.json(
      { error: "Sports card is being processed by another request. Please wait and refresh." },
      { status: 429 }
    );
  }

  try {
    processingSportsCards.set(cardId, Date.now());
    const supabase = supabaseServer();

    // Get sports card from database
    const { data: card, error: cardError } = await supabase
      .from("cards")
      .select("*")
      .eq("id", cardId)
      .eq("category", "Sports") // Ensure it's a sports card
      .single();

    if (cardError || !card) {
      console.error(`[GET /api/sports/${cardId}] Card lookup error:`, cardError);
      console.log(`[GET /api/sports/${cardId}] Card data:`, card);
      return NextResponse.json({ error: "Sports card not found" }, { status: 404 });
    }

    console.log(`[GET /api/sports/${cardId}] Sports card found`);

    // Create signed URLs for sports card images
    console.log(`[GET /api/sports/${cardId}] Creating signed URLs for front: ${card.front_path}, back: ${card.back_path}`);
    const frontUrl = await createSignedUrl(supabase, "cards", card.front_path);
    const backUrl = await createSignedUrl(supabase, "cards", card.back_path);

    if (!frontUrl || !backUrl) {
      console.error(`[GET /api/sports/${cardId}] Failed to create signed URLs. Front: ${frontUrl}, Back: ${backUrl}`);
      return NextResponse.json({ error: "Failed to access sports card images" }, { status: 500 });
    }
    console.log(`[GET /api/sports/${cardId}] Signed URLs created successfully`);

    // Check if sports card already has complete grading data
    const hasCompleteGrading = card.ai_grading && card.raw_decimal_grade && card.dcm_grade_whole;

    if (hasCompleteGrading) {
      console.log(`[GET /api/sports/${cardId}] Sports card already fully processed, returning existing result`);
      return NextResponse.json({
        ...card,
        front_url: frontUrl,
        back_url: backUrl,
        processing_time: Date.now() - startTime
      });
    }

    // If incomplete grading, process it
    if (!hasCompleteGrading) {
      console.log(`[GET /api/sports/${cardId}] Sports card needs grading analysis`);
    }

    // Perform sports-specific AI grading with retry logic
    console.log(`[GET /api/sports/${cardId}] Starting sports card AI grading`);
    let gradingResult;
    let attempts = 0;
    const maxRetries = 2;

    while (attempts < maxRetries) {
      try {
        attempts++;
        console.log(`[GET /api/sports/${cardId}] AI grading attempt ${attempts}/${maxRetries}`);
        const { gradingResult: aiResult } = await gradeSportsCardWithAI(frontUrl, backUrl);
        gradingResult = aiResult;
        break; // Success, exit retry loop
      } catch (error: any) {
        console.error(`[GET /api/sports/${cardId}] AI grading attempt ${attempts} failed:`, error.message);

        if (attempts >= maxRetries) {
          console.error(`[GET /api/sports/${cardId}] All AI grading attempts failed, providing fallback response`);

          // Provide a fallback grading structure for user feedback
          gradingResult = {
            "Final Score": {
              "Overall Grade": "Unable to process automatically"
            },
            "Card Information": {
              "Card Name": "Processing Error",
              "Category": "Sports",
              "Card Number": "N/A",
              "Serial Numbering": "N/A",
              "Manufacturer Name": "N/A",
              "Release Date": "N/A",
              "Authentic": "Cannot determine"
            },
            "Card Details": {
              "Player(s)/Character(s) Featured": "N/A",
              "Rookie/First Print": "N/A",
              "Rarity": "Unable to determine due to processing error",
              "Autographed": "N/A"
            },
            "Grading (DCM Master Scale)": {
              "Raw Decimal Grade (Before Rounding)": 0,
              "DCM Grade (Final Whole Number)": 0,
              "Subgrade Evaluation": {
                "Processing Error": {
                  "score": 0,
                  "commentary": `AI grading failed after ${maxRetries} attempts. Please try uploading again or contact support. Error: ${error.message.substring(0, 100)}`
                }
              }
            },
            "DCM Estimated Value": {
              "Estimated Market Value": "Cannot estimate",
              "Estimated Range": "N/A",
              "Estimate Confidence": "N/A"
            }
          };
          break; // Exit retry loop with fallback data
        }

        // Wait before retry
        console.log(`[GET /api/sports/${cardId}] Retrying in 3 seconds...`);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    console.log(`[GET /api/sports/${cardId}] Sports card AI grading completed after ${attempts} attempts`);

    // Extract sports card grade information
    const { rawGrade, wholeGrade, confidence } = extractSportsGradeInfo(gradingResult);

    // Extract key fields for database columns
    const cardFields = extractSportsCardFields(gradingResult);


    // Update database with comprehensive sports card data
    const updateData = {
      // Full AI grading JSON for comprehensive display
      ai_grading: gradingResult,

      // Grade information
      raw_decimal_grade: rawGrade,
      dcm_grade_whole: wholeGrade,
      ai_confidence_score: confidence,
      final_dcm_score: wholeGrade.toString(),

      // Individual searchable/sortable columns
      ...cardFields,

      // Processing metadata
      processing_time: Date.now() - startTime
    };

    console.log(`[GET /api/sports/${cardId}] Updating database with extracted fields:`, {
      card_name: cardFields.card_name,
      card_set: cardFields.card_set,
      featured: cardFields.featured,
      grade: wholeGrade
    });

    const { error: updateError } = await supabase
      .from("cards")
      .update(updateData)
      .eq("id", cardId);

    if (updateError) {
      console.error(`[GET /api/sports/${cardId}] Database update failed:`, updateError);
      return NextResponse.json({ error: "Failed to save sports card grading results" }, { status: 500 });
    }

    console.log(`[GET /api/sports/${cardId}] Sports card request completed in ${Date.now() - startTime}ms`);

    // Return updated sports card data
    return NextResponse.json({
      ...card,
      ai_grading: gradingResult,
      raw_decimal_grade: rawGrade,
      dcm_grade_whole: wholeGrade,
      ai_confidence_score: confidence,
      final_dcm_score: wholeGrade.toString(),
      ...cardFields,
      front_url: frontUrl,
      back_url: backUrl,
      processing_time: Date.now() - startTime
    });

  } catch (error: any) {
    console.error(`[GET /api/sports/${cardId}] Error:`, error.message);
    return NextResponse.json(
      { error: "Failed to process sports card: " + error.message },
      { status: 500 }
    );
  } finally {
    processingSportsCards.delete(cardId);
    console.log(`[GET /api/sports/${cardId}] Removed from processing set`);
  }
}